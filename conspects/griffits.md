
Компилятор начнет выполнять програму с функции main().Если такой функции не будет, то программа не запустится.

**Возращаемый тип** главной функции - int. Что бы определить успешно выполнилась функция или нет проверяется значение, возвращаемое главной функцией. Если функций main() возвращает 0, это значит, что программа завершилась успешно.

Имя функции идет вслед за возвращаемым типом. После этого идут параметы функции и тело функции.

Функция **printf()** используется для отображения форматированного ввода. Вместо символов-спецификаторов она подставляет значения переменных.

* **%s**
* **%i**

Язык Си изначально не имеет поддержки строк. Вместо строк в Си обычно используют *массив отдельных символов*. Си не всегда точно может определить какова длина массива. Если Си собирается вывести на экран строку, он должен знать, в каком месте заканчивается массив символов. Это делается с помощью **нуль-символа**.

Нуль-символ добавляется в конце строки и имеет значение \0. Это означает что, когда компьютер видит строку:

~~~c
s = "Shatner"
~~~
Он вдействительно помещает ее в память в таком виде:
~~~c
[S][h][a][t][n][e][r][\0]
~~~
Строка должна заканчиваться нуль-символом, поэтому нам нужно оставить в массиве место для дополнительного элемента.















##Как передать строку в функцию

Строки в Си на самом деле являются масивами символов. Следвательно, если вы хотите передать в функцию строку, это можно сделать так:

	```c
	void say(char msg[])
	{
	  print("Сообщение гласит: %s\n", msg);
	}

	char hello[] = "Привет";
	say(hello);```

Аргумент msg определен как массив, но он не содержит информации о длине массива.

##Оператор sizeof

С помощью оператора sizeof можно узнать сколько байтов что-то занимает в памяти. Ему можно передать тип данных или сами данные.
sizeof(массив) - это размер массива.

Переменные массивов похожи на указатели

Переменную массива можно использовать в качестве указателя на начало массива в памяти.
~~~c
	printf("Строка hello хранится по адресу: %p\n", quote);
~~~
Результат: 
~~~c
	Строка hello хранится по адресу: 0x7fff69d44bdd7
~~~
Можно использовать hello как ссылочную переменную, даже не смотря на то что это массив. 
При создании ссылочной переменной компьютер выделяет под нее 4(8)байт. При создании массива компьютер выделяет память только под сам массив, а не для его переменной. Вместо переменной компилятор вставляет адрес начала массива.
~~~c
	int drinks[] = {4, 3, 2};
	drinks[0] == *drinks
~~~
Можно производить с указателем арифметические действия:
~~~c
	drinks[2] == *(drinks + 2)
~~~
Индекс это всего лишь число, которое добавляется к указателю, что бы найти местоположение элемента.

##Расспад массива

Присваивая массив ссылочной переменно мы передаем ей только адрес массива, без сведений о его размере. Передавая массив в функцию, он расспадается до указателя. 
Функциям, которые обновляют переменные, нужно не само значение, а его адрес.

Использование указателя для ввода данных

Получить строку с клавиатуры можно с помощью scanf(). Эта функция принимает указатель типа char. Обязательно нужно ограничивать длину строки считываемой с помощью scanf(), так как scanf() записывает данные за пределами того участка который был выдан массиву.
Функция fets(), так же как и scanf() принимает указатель типа char, отличие в том что функции должна быть переданна максимальная длина
(включая \0):
~~~c
	char food[5];
	printf("Введите любимую еду: ");
	fgets(food, sizeof(food), stdin);
~~~
Если используем sizeof удостовериться что мы передаем массив, а не ссылочную переменную. Если передается указатель, то размер вводим вручную. 
~~~c
	fgets(food, 5, stdin);
~~~
scanf() позволяет вводить несколько полей и поддерживает структурированные данные, представляя возможность указывать символы, которые будут вставленны между полями:
~~~c
	char first_name[20];
	char last_name[20];
	printf("Введите имя и фамилию: ");
	scanf("%19s %19s, first_name, last_name);
	printf("Имя: %s Фамилия: %s\n", first_name, last_name);
~~~
Считывая строку со спецификатором %s функция останавливается, втретив пробел. 

fgets() позволяет вводить только одну строку, ни каких проблем с пробелами.

















































































































































